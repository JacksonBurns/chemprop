from abc import ABC, abstractmethod
from typing import Optional, Sequence, Union

import numpy as np
from rdkit import Chem

from chemprop.v2.featurizers.molgraph import MolGraph
from chemprop.v2.featurizers.atom import AtomFeaturizer, AtomFeaturizerBase
from chemprop.v2.featurizers.bond import BondFeaturizer, BondFeaturizerBase


class MolGraphFeaturizerMixin(ABC):
    def __init__(
        self,
        atom_featurizer: Optional[AtomFeaturizerBase] = None,
        bond_featurizer: Optional[BondFeaturizerBase] = None,
        bond_messages: bool = True,
    ):
        self.atom_featurizer = atom_featurizer or AtomFeaturizer()
        self.bond_featurizer = bond_featurizer or BondFeaturizer()
        self.atom_fdim = len(self.atom_featurizer)
        self.bond_fdim = len(self.bond_featurizer)
        self.bond_messages = bond_messages

        
    def __call__(self, *args, **kwargs):
        return self.featurize(*args, **kwargs)

    @property
    def shape(self) -> tuple[int, int]:
        """the feature dimension of the atoms and bonds, respectively, of `MolGraph`s generated by
        this featurizer"""
        return self.atom_fdim, self.bond_fdim

    @abstractmethod
    def featurize(
        self,
        mol_or_reaction: Union[Chem.Mol, tuple[Chem.Mol, Chem.Mol]],
        atom_features_extra: Optional[np.ndarray] = None,
        bond_features_extra: Optional[np.ndarray] = None,
    ) -> MolGraph:
        pass


class MultiHotFeaturizerMixin(ABC):
    """A `MultiHotFeaturizer` calculates feature vectors of arbitrary objects by concatenating
    multiple one-hot feature vectors"""

    def __call__(self, x) -> np.ndarray:
        return self.featurize(x)

    @abstractmethod
    def __len__(self) -> int:
        """the length of a feature vector from this featurizer"""

    @property
    @abstractmethod
    def subfeatures(self) -> Sequence[tuple[str, slice]]:
        """a list of tuples containing the subfeature name and its respective slice in the output 
        feature vectors"""

    @abstractmethod
    def featurize(self, x) -> np.ndarray:
        """calculate the feature vector of x"""

    @property
    def num_subfeatures(self) -> int:
        return len(self.subfeatures)

    @staticmethod
    def one_hot_index(x, xs: Sequence) -> tuple[int, int]:
        """return the index of a one hot encoding of `x` given choices `xs` and the length of the
        uncompressed encoding"""
        n = len(xs)
        
        return xs.index(x) if x in xs else n, n + 1
